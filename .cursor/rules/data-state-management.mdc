---
globs: "*.ts,*.tsx"
description: "Data handling, state management, and API integration patterns"
---

# Data Handling & State Management

## State Management Architecture

### 1. State Types and Tools
```tsx
// LOCAL COMPONENT STATE - useState
const [isOpen, setIsOpen] = useState(false);
const [selectedItems, setSelectedItems] = useState<string[]>([]);

// SERVER STATE - TanStack Query (React Query)
const { data, isLoading, error } = useQuery({
  queryKey: ['posts', orgId, filters],
  queryFn: () => fetchPosts(orgId, filters),
});

// GLOBAL CLIENT STATE - Zustand
const { theme, setTheme } = useThemeStore();
const { user, permissions } = useAuthStore();

// FORM STATE - React Hook Form
const { register, handleSubmit, formState } = useForm<FormData>();
```

### 2. Data Fetching Patterns

#### Query Key Conventions
```tsx
// REQUIRED: Hierarchical query keys
const queryKeys = {
  // Top level
  orgs: ['orgs'] as const,
  org: (id: string) => ['orgs', id] as const,
  
  // Nested resources
  posts: (orgId: string) => ['orgs', orgId, 'posts'] as const,
  post: (orgId: string, postId: string) => ['orgs', orgId, 'posts', postId] as const,
  
  // Filtered/paginated data
  postsList: (orgId: string, filters: PostFilters) => 
    ['orgs', orgId, 'posts', 'list', filters] as const,
};

// Usage
const { data: posts } = useQuery({
  queryKey: queryKeys.postsList(orgId, filters),
  queryFn: () => fetchPosts(orgId, filters),
});
```

#### Error Handling Pattern
```tsx
// REQUIRED: Consistent error handling
function useDataWithError<T>(
  queryKey: QueryKey,
  queryFn: QueryFunction<T>
) {
  const query = useQuery({ queryKey, queryFn });
  
  const errorMessage = useMemo(() => {
    if (!query.error) return null;
    
    if (query.error.status === 403) {
      return "You don't have permission to view this data";
    }
    if (query.error.status === 404) {
      return "Data not found";
    }
    return "An error occurred loading data";
  }, [query.error]);
  
  return {
    ...query,
    errorMessage,
  };
}
```

### 3. Mutation Patterns

#### Optimistic Updates
```tsx
// REQUIRED: Optimistic updates for better UX
const updatePostMutation = useMutation({
  mutationFn: updatePost,
  onMutate: async (newPost) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries({ queryKey: ['posts', orgId] });
    
    // Snapshot previous value
    const previousPosts = queryClient.getQueryData(['posts', orgId]);
    
    // Optimistically update
    queryClient.setQueryData(['posts', orgId], (old: Post[]) =>
      old.map(post => post.id === newPost.id ? { ...post, ...newPost } : post)
    );
    
    return { previousPosts };
  },
  onError: (err, newPost, context) => {
    // Rollback on error
    queryClient.setQueryData(['posts', orgId], context?.previousPosts);
  },
  onSettled: () => {
    // Refetch after mutation
    queryClient.invalidateQueries({ queryKey: ['posts', orgId] });
  },
});
```

#### Bulk Operations
```tsx
// REQUIRED: Handle bulk operations efficiently
const bulkUpdateMutation = useMutation({
  mutationFn: async (updates: BulkUpdate[]) => {
    // Process in batches to avoid overwhelming the server
    const batches = chunk(updates, 50);
    const results = [];
    
    for (const batch of batches) {
      const result = await bulkUpdatePosts(batch);
      results.push(...result);
    }
    
    return results;
  },
  onSuccess: () => {
    // Invalidate affected queries
    queryClient.invalidateQueries({ queryKey: ['posts', orgId] });
    toast.success(`Updated ${updates.length} items`);
  },
});
```

## Type Safety

### 1. API Response Types
```tsx
// REQUIRED: Define strict types for all API responses
interface ApiResponse<T> {
  data: T;
  meta: {
    total: number;
    page: number;
    pageSize: number;
    hasNext: boolean;
  };
  errors?: ApiError[];
}

interface Post {
  id: string;
  content: string;
  author: string;
  createdAt: string; // ISO string
  score: number;
  tags: string[];
  metadata: PostMetadata;
}

// Use branded types for IDs to prevent mixing
type OrgId = string & { __brand: 'OrgId' };
type PostId = string & { __brand: 'PostId' };
```

### 2. Form Validation
```tsx
// REQUIRED: Use Zod for runtime validation
import { z } from 'zod';

const postSchema = z.object({
  title: z.string().min(1, 'Title is required').max(200, 'Title too long'),
  content: z.string().min(10, 'Content must be at least 10 characters'),
  tags: z.array(z.string()).max(10, 'Maximum 10 tags allowed'),
  publishedAt: z.date().optional(),
});

type PostFormData = z.infer<typeof postSchema>;

// Usage with React Hook Form
const form = useForm<PostFormData>({
  resolver: zodResolver(postSchema),
});
```

## Real-time Data

### 1. WebSocket/SSE Integration
```tsx
// REQUIRED: Handle real-time updates gracefully
function useRealtimeUpdates(orgId: string) {
  const queryClient = useQueryClient();
  
  useEffect(() => {
    const eventSource = new EventSource(`/api/realtime/${orgId}`);
    
    eventSource.addEventListener('post_created', (event) => {
      const newPost = JSON.parse(event.data) as Post;
      
      // Update cache
      queryClient.setQueryData(['posts', orgId], (old: Post[] = []) => 
        [newPost, ...old]
      );
    });
    
    eventSource.addEventListener('post_updated', (event) => {
      const updatedPost = JSON.parse(event.data) as Post;
      
      // Update specific post in cache
      queryClient.setQueryData(['posts', orgId], (old: Post[] = []) =>
        old.map(post => post.id === updatedPost.id ? updatedPost : post)
      );
    });
    
    return () => eventSource.close();
  }, [orgId, queryClient]);
}
```

### 2. Polling Strategy
```tsx
// USE polling for less critical updates
const { data } = useQuery({
  queryKey: ['system-health', orgId],
  queryFn: () => fetchSystemHealth(orgId),
  refetchInterval: 30000, // 30 seconds
  refetchIntervalInBackground: false,
});
```

## Caching Strategy

### 1. Cache Configuration
```tsx
// REQUIRED: Configure appropriate cache times
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Static data (rarely changes)
      staleTime: 10 * 60 * 1000, // 10 minutes
      cacheTime: 30 * 60 * 1000, // 30 minutes
      
      // User preferences
      retry: 3,
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
  },
});

// Different strategies for different data types
const useStaticData = (key: string) => useQuery({
  queryKey: [key],
  staleTime: Infinity, // Never stale
  cacheTime: Infinity, // Never garbage collect
});

const useLiveData = (key: string) => useQuery({
  queryKey: [key],
  staleTime: 0, // Always stale
  refetchInterval: 5000, // Refetch every 5 seconds
});
```

### 2. Cache Invalidation
```tsx
// REQUIRED: Strategic cache invalidation
const handleOrgSwitch = (newOrgId: string) => {
  // Clear all data for previous org
  queryClient.removeQueries({
    predicate: (query) => {
      const [type, orgId] = query.queryKey;
      return type === 'orgs' && orgId !== newOrgId;
    },
  });
};

// Invalidate related data after mutations
const createPostMutation = useMutation({
  mutationFn: createPost,
  onSuccess: () => {
    // Invalidate lists but keep individual posts cached
    queryClient.invalidateQueries({ 
      queryKey: ['posts', orgId, 'list'],
      exact: false 
    });
  },
});
```

## Error Boundaries and Fallbacks

### 1. Data Error Boundaries
```tsx
// REQUIRED: Graceful data error handling
function DataErrorBoundary({ children }: { children: React.ReactNode }) {
  return (
    <ErrorBoundary
      fallback={({ error, resetError }) => (
        <div className="p-6 text-center">
          <h3 className="text-lg font-semibold mb-2">Data Loading Error</h3>
          <p className="text-muted-foreground mb-4">
            Unable to load data. Please try again.
          </p>
          <Button onClick={resetError} variant="outline">
            Retry
          </Button>
        </div>
      )}
    >
      {children}
    </ErrorBoundary>
  );
}
```

### 2. Offline Handling
```tsx
// HANDLE offline scenarios
function useOfflineSync() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      // Retry failed mutations
      queryClient.resumePausedMutations();
    };
    
    const handleOffline = () => setIsOnline(false);
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  return { isOnline };
}
```